// analysis for the module 1 design project (2014-2015)
/* designed to include the blocks visible with the bug (the original design 
 * activity restricted what blocks you could use, but if you reset the activity, 
 * more blocks appeared.)
 */

exports.process = function (xmlObj) {
  var result = {};
  var events = {};
  
  // loop through blockNames to get #use per block
  // loop through categoryNames to get #use per category 
  
  events.uniqueBlocks = 0; // capture number of unique blocks used
  events.uniqueCategories = 0;
  events.blockTotal = 0;
  events.eventBlocks = 0; // capture number of unique event blocks 
  
  events.scriptsTotal = 0;
  events.spritesTotal = 0;
  events.maxLen = 0;
  events.medianLen = 0;


  var categoriesUsed = []; // collect unique categories used
  var blocksUsed = []; // collect unique blocks that have been used
  var eventBlocksUsed = []; // collect unique event blocks used
  var scriptLen = []; // get the length of each script

  // all the block names; 
  var blockNames  = Array("bubble", "changeEffect", "clear", "clearEffects",
   "doAsk", "doBroadcast", "doFaceTowards", "doForever", "doGlideCoord", 
   "doGlideDirection", "doGotoObject", "doHideVar", "doIfElse", "doRepeat",
   "doSayFor", "doSetVar", "doShowVar", "doSpeedGlideSteps", "doSpeedGlidetoObject",
   "doSwitchToCostume", "doThink", "doThinkFor", "doUntil", "doWait", 
   "doWaitUntil", "doWearNextCostume", "down", "getReady", "gotoXYNegative",
   "hide", "incDecScale", "otherReceiveClick", "placeDirection", "playSound",
   "receiveClick", "receiveGo", "receiveKey", "receiveMessage", "reportModulus",
   "setColor", "setEffect", "setHeading", "setScaleDropDown", "show", "turn",
   "turnLeft", "up");

  // sort the block names into their categories:
  var motionBlocks = Array("doFaceTowards", "doGlideCoord", 
   "doGlideDirection", "doGotoObject", "doSpeedGlideSteps", "doSpeedGlidetoObject",
   "gotoXYNegative", "placeDirection", "setHeading", "turn",
   "turnLeft");
  motionBlocks.name = "motionBlocks";

  var looksBlocks = Array("bubble", "changeEffect",  "clearEffects", "doSayFor",
   "doSwitchToCostume", "doThink", "doThinkFor", "doWearNextCostume", "hide",
   "incDecScale", "setEffect", "setScaleDropDown", "show");
  looksBlocks.name = "looksBlocks";

  var sensingBlocks = Array("doAsk"); 
  sensingBlocks.name = "sensingBlocks";

  var varBlocks = Array("doHideVar", "doSetVar", "doShowVar");
  varBlocks.name = "varBlocks";

  var eventsBlocks = Array("doBroadcast", "getReady", "otherReceiveClick", 
    "receiveClick", "receiveGo", "receiveKey", "receiveMessage");
  eventsBlocks.name = "eventsBlocks";

  var controlBlocks = Array( "doForever", "doIfElse", "doRepeat",  "doUntil",
   "doWait", "doWaitUntil", "reportModulus");
  controlBlocks.name = "controlBlocks";

  var soundBlocks = Array("playSound");
  soundBlocks.name = "soundBlocks";

  var penBlocks = Array("clear", "setColor", "down", "up");
  penBlocks.name = "penBlocks";

  var categoryNames = Array(motionBlocks, looksBlocks, sensingBlocks, 
    varBlocks, eventsBlocks, controlBlocks, soundBlocks, penBlocks);


  for (var i = 0; i < blockNames.length; i++){
    var block_name = blockNames[i];
    events[block_name] = 0;
  }

  for (i = 0; i < categoryNames.length; i++){
    var category_name = categoryNames[i].name;
    events[category_name] = 0;
  }
  
  try{
    var hasScript = 0;
    // iterate over all the sprites:
    xmlObj.project.stage[0].sprites[0].sprite.forEach(function (sprites){
      if (sprites.scripts[0].length !== 0) // if sprite is not empty
        events.spritesTotal += 1;
      // iterate through all the scripts in this sprite: 
      sprites.scripts[0].script.forEach(function (scr){
          // does the script start with an event block?:
          var block = scr.block[0].$.s;
          if (eventsBlocks.indexOf(block) != -1){
            // deal with the starter event block:
            if (eventBlocksUsed.indexOf(block) == -1){
              eventBlocksUsed.push(block);
            }
            events[block] += 1; // add to total number of uses for this block
            if (blocksUsed.indexOf(block) == -1){ 
              // add block name to list of used blocks (if it isn't already there)
              blocksUsed.push(block);
            }
            events[eventsBlocks.name] += 1; // add to total number of uses for this category
            if (categoriesUsed.indexOf(eventsBlocks.name) == -1){
              // add this category to list of unique categories used
              categoriesUsed.push(eventsBlocks.name);
            }

            events.scriptsTotal += 1;
            // scr.length = #scripts in this sprite
            var numBlocks = scr.block.length; // #blocks in this script
            scriptLen.push(numBlocks); 
            events.blockTotal += numBlocks;

            // iterate through each block in the rest of the script:
            for (i = 1; i < numBlocks; i++){
              block = scr.block[i].$.s;
              events[block] += 1;
              if (blocksUsed.indexOf(block) == -1){ 
                blocksUsed.push(block);
              }
              // check the category of this block:
              for (var j = 0; j < categoryNames.length; j++){
                category_name = categoryNames[j];
                // is the block in this category?:
                if (category_name.indexOf(block) != -1){
                  events[category_name.name] += 1;
                  if (categoriesUsed.indexOf(category_name) == -1){
                    categoriesUsed.push(category_name);
                  }
                  if (category_name == eventsBlocks){
                    if (eventBlocksUsed.indexOf(block) == -1){
                      eventBlocksUsed.push(block);
                    }
                  }
                }
              }
            }
          } // if script starts with an event block, analyze. Otherwise, go to next script

      });
    });
  }
  catch(err){}
  finally{
    
    if(((blocksUsed.doBroadcast > 0) && (blocksUsed.receiveMessage === 0))||
       ((blocksUsed.doBroadcast === 0) && (blocksUsed.receiveMessage > 0))) {
      blocksUsed.doBroadcast = 0;
      blocksUsed.receiveMessage = 0;
    }
    
    if(((blocksUsed.hide > 0) && (blocksUsed.show === 0))||
       ((blocksUsed.hide === 0) && (blocksUsed.show > 0))) {
      blocksUsed.hide = 0;
      blocksUsed.show = 0;
    }
    
    if(((blocksUsed.clear > 0) || (blocksUsed.setColor > 0) ||
        (blocksUsed.up > 0)) && (blocksUsed.down === 0)) {
      blocksUsed.clear = 0;
      blocksUsed.setColor = 0;
      blocksUsed.up = 0;
    }
    
    if(((blocksUsed.doGlideCoord > 0) || (blocksUsed.doGlideDirection > 0) || 
        (blocksUsed.doSpeedGlideSteps > 0) || (blocksUsed.doSpeedGlidetoObject > 0)) && 
       ((blocksUsed.doGotoObject === 0) || (blocksUsed.gotoXYNegative === 0))) {
      blocksUsed.doGlideCoord = 0;
      blocksUsed.doGlideDirection = 0;
      blocksUsed.doSpeedGlideSteps = 0;
      blocksUsed.doSpeedGlidetoObject = 0;
    }
/**/
    events.uniqueBlocks = blocksUsed.length;
    events.uniqueCategories = categoriesUsed.length;
    events.eventBlocks = eventBlocksUsed.length;
    events.maxLen = Math.max.apply(null, scriptLen);

    // find the median script length:
    scriptLen.sort(function(a, b) {return a - b;});
    var len = scriptLen.length;
    var half = len / 2;
    var val;
    if ((len % 2) !== 0){
      val = scriptLen[Math.floor(half)];
    } else {
      val = (scriptLen[half] + scriptLen[half - 1]) / 2;
    }
    events.medianLen = val;


    result.results = events;
    return result;
  }
};